# redis问题汇总
### 为什么用缓存? 
- 1、满足项目高性能
  - 每次查询mysql耗时太高，可以将数据处理好后，直接存入缓存数据库，减少响应时间
- 2、满足项目高并发
  - 并发场景不是很多，可以简单说说
### 缓存带来那些负面影响?
- 缓存与数据库双写不一致
- 缓存穿透、雪崩
- 缓存并发竞争
### 介绍一下缓存击穿、雪崩、穿透？
- 缓存穿透
  - 原因
    - 查询一个根本不存在的数据，缓存层和持久层都不会命中，请求直接压到数据库，从而压夸数据库。
  - 解决办法
    - 对空值缓存
    - 设置可访问的白名单
    - 采用布隆过滤器

- 缓存击穿
  - 原因
    - 缓存中没有但是数据库中有的数据，由于用户特别多，所有用户都去数据库中读取，导致数据库压力激增
  - 解决办法
    - 预先设置高频词,实时调整高频词汇，增加高频词汇的过期时长
    - 使用分布式锁，一个线程去读库，其他的设置等待

- 缓存雪崩
  - 原因
    - 大量缓存集中过期，查询数量巨大，引起数据库压力过大，甚至down机
  - 解决办法
    - 缓存数据过期时间设置为随机,防止同一时间大量数据过期
    - 设置部分热点数据永不过期
    - 分布式部署缓存数据库，将热点数据分布在不同的数据库中

### redis单线程模型
- 客户端与redis进行socket链接，产生AE_READABLE事件
- I/O多路复用程序监听socket程序，如果产生事件就会将socket压到队列
- 文件事件分派器监测socket队列,进行分派socket事件，连接应答处理器-->命令请求处理器-->命令回复处理器

### redis单线程为什么这么快?
- 不是完全的单线程, 只有在核心功能部分才是单线程
  - unlink删除、RDB持久化等都会开启子进程处理
- 单线程模型的设计
  - IO多路复用
  - 事件机制
- 底层数据结构的优化
  - 字符串使用 int + SDS结构(redis底层C语言实现的一种字符串)
  - 压缩列表的使用
  - 跳表的使用
  - 对象共享
    - redis 会对0-9999的数字实现对象内存共享
  - 等等...

### redis底层数据结构
类型|编码| 对象
  ---|---|---
  REDIS_STRING | REDIS_ENCDING_INT | 使用整数值实现的字符串对象
  REDIS_STRING | REDIS_ENCDING_EMBSTR | 使用embstr编码的简单动态字符串对象实现的字符串对象
  REDIS_STRING | REDIS_ENCDING_RAW | 使用简单动态字符串实现的字符串对象
  REDIS_LIST | REDIS_ENCODING_ZIPLIST | 使用压缩列表实现的列表对象
  REDIS_LIST | REDIS_ENCODING_LINKEDLIST | 使用双端链表实现的列表对象
  REDIS_HASH | REDIS_ENCODING_ZIPLIST | 使用压缩列表实现的哈希对象
  REDIS_HASH | REDIS_ENCODING_HT | 使用字典实现的哈希对象
  REDIS_SET | REDIS_ENCODING_INTLIST | 使用整数集合实现的集合对象
  REDIS_SET | REDIS_ENCODING_HT | 使用字典实现的集合对象
  REDIS_ZSET | REDIS_ENCODING_ZIPLIST | 使用压缩列表实现的有序集合对象
  REDIS_ZSET | REDIS_ENCODING_SKIPLIST | 使用跳跃表和字典实现的列表对象

- string 底层: int + string
- list 底层: 压缩列表 + 双端链表
- hash 底层: 压缩列表 + 字典
- set 底层:  整数集合 + 字典
- zset 底层: 压缩列表 + 跳跃表

### redis过期策略
- 常见的过期删除的方案
  - 立即删除
    - 设置回调函数，到期立即删除，影响cpu ，对空间友好
  - 惰性删除
    - 过期也不管，但是调用get时判断是否过期，如果过期，则删除，这种办法会浪费大量内存，队内存不友好，对性能友好。
  - 定时删除
    - 这是一个折中的办法，每隔一段时间做一次检查key，是否过期，如果过期则删除 
- redis 采用的是
  - 惰性删除 + 定时删除策略
- 每秒十次操作:
    - 1、测试随机的 20 个 keys 进行相关检测
    - 2、删除所有已经过期的keys
    - 3、如果有多于25%的keys过期，重复步骤一
- redis删除使用的是绝对的时间点(时间戳)
- 主从复制过程中AOF文件时处理过期时间
  - 为了获取正确的行为而不牺牲一致性，当一个key过期，DEL将会随着AOF文字一起合成到所有的slaves，在master实例中，这种方法是集中的，并且不存在一致性错误的机会。
- 主从库结构，查询从库
  - 如果查询的是从库，如果发现key 已经过期，但是master没有删除，那么从库会将这个key当作未过期的处理

### redis淘汰策略
- Redis有最大内存的限制，通过maxmemory参数可以设置最大内存，使用的内存超过了设置的最大内存，就要进行内存释放，内存释放就会根据淘汰策略
- 淘汰对象
  - 所有的key
  - 设置了过期时间的key
- 淘汰算法
  - volatile-lru
    - 最近最少使用算法，选择空转时间最长的键值对清除掉
  - volatile-lfu
    - 最近最不常用算法，选择某段时间之内使用频次最小的键值对删除掉
  - random
    - 随机删除 
  - volatitle-ttl
    - 从设置了过期时间的键值对中，删除最早过期的key-value

### redis 数据结构的应用场景
- string
  - 缓存、分布式锁
- list
  - 小型队列、列表存储
- set
  - 点赞、需要去重的场景
- zset
  - 热榜、排行榜、需要评分的场景

### redis 实现分布式锁
- 利用 redis的单线程操作，使用string数据结构，每次操作，判断key是否存在，为了容错，需要对key设置过期时间, 但还是会有一些问题
- 最严谨的是利用redis执行lua脚本的原子性来实现分布式锁...

### redis缓存的时候，如果数据更新对缓存怎么操作?
- 这是一个开放性的题，主要对场景的不同，答案也不尽相同。
- 方案一: 对于性能要求较高的场景，可以先更新缓存，利用消息队列异步落库, 这样不影响业务的及时性, 优点是及时跟新缓存，不影响读取效率，异步落库，性能优化。缺点: 如果落库失败，会导致一些问题，需要增添落库重试机制
- 方案二: 如果修改后无需马上生效，允许误差，可以直接更库，改小缓存的过期时间、或者直接不管缓存，这样的缺点就是，有一段时间走的缓存，查的是旧数据，优点是操作简单
- 方案三: 直接更库，然后删除缓存, 这样再查询就会直接将新数据作为缓存，缺点是需要一次查库，优点是保证逻辑完整性，数据落库和缓存都是最新的