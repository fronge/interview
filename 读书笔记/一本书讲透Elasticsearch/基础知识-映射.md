# 映射
- 映射是一种将数据结构与索引相关联的机制。它指定了存储在索引中的文档的字段类型和其他属性，例如是否为必需字段、是否允许空值等。映射还可以设置数据类型（例如字符串、整数、日期等）​，以及设置如何处理数据（例如是否分词或如何分词）。
## 组成部分
### 元字段
- 元字段用于自定义关于处理文档的相关元数据
- 标识元字段
  - _index：表示文档所属的索引
  - _id：表示文档的ID
- 文档源元字段
  - _source：表示代表文档正文的原始JSON对象
  - _size：表示source字段的大小（以字节为单位）​。
- 索引元字段
  - _field_names：表示给定文档中包含非空值的所有字段
  - _ignored：表示由于设置ignore_malformed而在索引时被忽略的字段
- 路由元字段
  - _routing：用于将给定文档路由到指定的分片
- 其他元字段
  - _meta：表示应用程序特定的元数据，通俗地解读为可用于给索引加必要注释信息
  - _tier：指定文档所属索引的数据层级别，如在查询文档时可以指定data_hot、data_warm、data_cold等

### 数据类型字段
- 基本数据类型
  - binary：编码为Base64字符串的二进制类型
  - boolean：仅支持true和false的布尔类型
  - keyword：支持精准匹配的keyword类型、const_keyword类型和wildcard类型
  - number：数值类型，如integer、long、float、double等
  - date：日期类型，包括date和date_nanos
  - alias：别名类型，区别于索引别名，此处的别名是字段级别的别名
  - text：全文检索类型
- 复杂数据类型
  - 数组类型：Array
  - JSON对象类型：Object
  - 嵌套数据类型：Nested
  - 父子关联类型：Join
  - Flattened类型：将原来一个复杂的Object或者Nested嵌套多字段类型统一映射为扁平的单字段类型
- 专用数据类型
  - 坐标数据类型：用于保存地理位置详细信息
  - IP类型：表示IPV4或IPV6地址
  - completion类型：是Elasticsearch中的一种专用字段类型，旨在实现高效的自动补全功能
- 多字段类型
  - 允许用户对单个文档字段设定多种不同的数据类型，以满足不同查询需求

#### 数据类型详解
##### binary
- binary类型接受二进制值作为 Base64编码的字符串。默认情况下不存储该字段，并且不可搜索
##### boolen
- 布尔字段接受 JSONtrue和false值，但也可以接受被解释为 true 或 false 的字符串

命令|含义|
| -| -
|错误值 | false, "false", ""（空字符串）|
| 真实值 | true, "true" |

##### completion
命令|参数|
| -| -
analyzer | 使用的索引分析器，默认为simple。
search_analyzer | 要使用的搜索分析器，默认值为analyzer。
preserve_separators | 保留分隔符，默认为true。如果禁用，您可以找到以 开头的字段Foo Fighters，如果您建议foof。
preserve_position_increments | 启用位置增量，默认为true。如果禁用并使用停用词分析器，您可以获得以 开头的字段The Beatles，如果您建议b。注意：您也可以通过索引两个输入Beatles和 来实现这一点The Beatles，如果您能够丰富您的数据，则无需更改简单的分析器。
max_input_length | 限制单个输入的长度，默认为50UTF-16 代码点。此限制仅在索引时使用，以减少每个输入字符串的总字符数，从而防止大量输入导致底层数据结构膨胀。大多数用例不会受到默认值的影响，因为前缀补全很少会超出长度超过几个字符的前缀。

##### 日期类型
- json 没有日期类型，所以日期可以是以下几种:
  - 包含格式化日期的字符串，例如"2015-01-01"或"2015/01/01 12:10:30"。
  - 一个代表自纪元以来的毫秒数的数字。
  - 一个表示自纪元以来秒数的数字（配置）。
- 日期格式可以自定义，但如果未format指定，则使用默认格式

##### 数值数据类型

## 映射类型
### 动态映射
- 动态映射的核心是在自动检测字段类型后添加新字段
- 支持字段类型：boolean类型、float类型、long类型、Object类型、Array类型、date类型、字符串类型
- 弊端
  - 字段匹配不准确
  - 字段匹配不精准
  - 占据多余的存储空间
  - 映射可能错误泛滥
### 静态映射
- 我们在数据建模前，需要明确文档中各个字段的类型
- 将dynamic参数设置为false（表示忽略新字段）​，或者将dynamic参数设置为strict（表示如果遇到未知字段，则引发异常）​。

### 映射可以更新么?
- 已经定义的字段在大多数情况下不能更新, 除非通过reindex操作来更新映射
- 可以更新的情况
    - Object对象可以添加新的属性
    - 在已经存在的字段里面可以添加fields，以构成一个字段多种类型
    - ignore_above是可以更新的

### Nested类型及应用
- Nested类型也被称作嵌套数据类型
- Nested类型是Object数据类型的升级版本，它允许对象以彼此独立的方式进行索引。

##  Join类型及应用
### 定义
- Join类型允许在同一个索引下通过父子关系来实现类似于MySQL中多表关联的操作。使用Join类型时，我们需要在映射中定义一个名为“join”的字段，并为其分配一个或多个关系名称。这些关系名称定义了父子文档之间的层次结构，使得我们能够在查询时进行关联操作
#### 映射定义
```
PUT my_index
{
  "mappings": {
    "properties": {
      "my_join_field": {
        "type": "join",
        "relations": {
          "question": "answer"
        }
      }
    }
  }
}
```
#### 父文档定义
```
PUT my_index/_doc/1
{
  "text": "Some text",
  "my_join_field": {
    "name": "question"
  }
}
```

#### 子文档定义
```
PUT my_index/_doc/3?routing=1
{
  "text": "Some text",
  "my_join_field": {
    "name": "answer",
    "parent": "1"
  }
}

```

#### 特点
- 对于每个索引，仅允许定义一个与Join类型关联的映射
- 父文档和子文档必须在同一个分片上写入索引
- 一个文档可以有多个子文档，但一个子文档只能有一个父文档
- 可以为已经存在的Join类型添加新的关系
- 当一个文档已经成为父文档后，就可以为该文档添加子文档

## Flattened类型
- 膨胀问题
  - 如果映射不进行设置, 默认使用dynamic:true
    - 不约束动态增加字段，会导致大量未知字段，如果字段持续激增，会达到ES默认的最大值上限,这种非预期的膨胀会导致内存溢出等问题。
    - 膨胀导致性能问题，比如查询、搜索、索引操作等等，都需要遍历字段，而膨胀的字段只会拖累性能
  - 默认会按照不同的数据类型进行动态的设置字段类型, 无法做到字段类型的一致性.
    - 查询、搜索、索引操作等等，都会浪费时间进行类型转换
 - Flattened的本质是将原来一个复杂的Object或者Nested嵌套多字段类型统一映射为扁平的单字段类型。这里要强调的是：不管原来内嵌多少个字段、内嵌多少层，利用Flattened类型都能一下“拉平”​。

 ## 内部数据结构解读
### 数据存储的基础知识
